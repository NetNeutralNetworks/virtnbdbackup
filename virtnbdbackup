#!/usr/bin/env python3
import os
import sys
import json
import logging
import argparse

import libvirtnbdbackup.nbdhelper as nbdhelper
import libvirtnbdbackup.extenthandler as extenthandler
import libvirtnbdbackup.sparsestream  as sparsestream
import libvirtnbdbackup.qemuhelper as qemuhelper
import libvirtnbdbackup.libvirthelper as libvirthelper

CHECKPOINTDIR="./checkpoints/"

def main():
    logging.getLogger("sh").setLevel(logging.WARNING)
    parser = argparse.ArgumentParser(description='Backup')
    parser.add_argument("-t", "--type", default="stream",
        choices=['stream','raw'],
        type=str,
        help="Output type: stream or raw")
    parser.add_argument("-l", "--level", default="copy",
        choices=['copy','full','inc'],
        type=str,
        help="Backup level, defaults to copy")
    parser.add_argument("-f", "--file", required=True,
        type=str,
        help="Output target file prefix")
    parser.add_argument("-d", "--domain", required=True,
        type=str,
        help="Domain to backup")
    parser.add_argument("-q", "--qemu", default=False,
        help="Use Qemu tools to query extents",
        action="store_true")
    parser.add_argument("-v", "--verbose", default=False,
        help="Enable debug output",
        action="store_true")
    parser.add_argument("-i", "--include", default=None,
        type=str,
        help="Backup only disk with target dev name specified")
    parser.add_argument("-s", "--startonly", default=False,
        help="Only initialize backup job via libvirt, do not backup any data",
        action="store_true")
    parser.add_argument("-k", "--killonly", default=False,
        help="Kill any running block job",
        action="store_true")

    try:
        args = parser.parse_args()
    except:
        parser.print_help()
        sys.exit(1)

    logger = logging
    if args.verbose == True:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.basicConfig(level=level)

    try:
        virtClient = libvirthelper.client()
        disks = virtClient.getDomainDisks(args.domain)
    except Exception as e:
        logging.error('Unable to get domain information: %s' % e)
        sys.exit(1)

    logger.info("Domain has %s disks attached" % len(disks))

    if args.killonly == True:
        logger.info("Stopping domain jobs")
        try:
            virtClient.stopBackup(disks[0].diskTarget)
        except Exception as e:
            logging.warn('%s' % e)
        sys.exit(0)

    checkpointName = "virtnbdbackup"
    parentCheckpoint = None
    checkpoints = []
    if args.level != "copy":
        logging.info('Looking for checkpoints')
        cptFile = '%s/%s.cpt' % (CHECKPOINTDIR, args.domain)
        if os.path.exists(cptFile):
            with open(cptFile,'r') as cptFh:
                checkpoints = json.loads(cptFh.read())

            if args.level == "full" and len(checkpoints) > 0:
                logging.info("Removing all existant checkpoints before full backup")
                virtClient.removeAllCheckpoints(checkpoints)
                os.remove(cptFile)
                checkpoints = []

            if len(checkpoints) > 0 and args.level == "inc":
                nextCpt = len(checkpoints)+1
                checkpointName = "virtnbdbackup.%s" % nextCpt
                parentCheckpoint = checkpoints[-1]
                logging.info("Parent checkpoint name %s" % parentCheckpoint)
                logging.info('Found checkpoints, next name: %s' % nextCpt)
        else:
            if args.level == "inc":
                logger.error("No prior checkpoints found, execute full backup first")
                sys.exit(1)

        logging.info("Using checkpoint name %s" % checkpointName)

    try:
        virtClient.startBackup(disks, args.level, checkpointName, parentCheckpoint)
    except Exception as e:
        logging.error('%s' % e)
        sys.exit(1)

    if args.level != "copy":
        logging.info('Started backup with checkpoint, saving information')
        if not os.path.exists(CHECKPOINTDIR):
            os.mkdir(CHECKPOINTDIR)
        if len(checkpoints) < 1:
            checkpoints = []
        checkpoints.append(checkpointName)
        with open(cptFile,'w') as cFw:
            cFw.write(json.dumps(checkpoints))

    if args.startonly == True:
        logging.info("Exiting after backup Start")
        sys.exit(0)

    for disk in disks:
        if args.include != None and disk.diskTarget != args.include:
            logging.info("Skipping disk: %s" % disk.diskTarget)
            continue
        try:
            backupDisk(disk.diskTarget,args, logger, checkpointName)
        except Exception as e:
            logger.error('%s' % e)
            virtClient.stopBackup(disk.diskTarget)
            sys.exit(1)

    virtClient.stopBackup(disk.diskTarget)

def backupDisk(diskTarget, args, logger, checkpointName):
    metaContext = None
    if args.level == "inc":
        metaContext = "qemu:dirty-bitmap:backup-%s" % diskTarget
        logger.info("INC backup: set context to %s" % metaContext)

    nbdClient = nbdhelper.nbdClient(diskTarget, metaContext)
    connection = nbdClient.connect()

    if args.qemu and args.level != "inc":
        logger.info("Using qemu tools to query extents")
        extentHandler = extenthandler.ExtentHandler(qemuhelper.qemuHelper(diskTarget))
    else:
        logger.info("Using nbd to query extents")
        extentHandler = extenthandler.ExtentHandler(
            connection,
            metaContext
        )

    extents = extentHandler.queryBlockStatus()

    if extents == None:
        logging.error("No extents found")
        return

    thinBackupSize = sum([extent.length for extent in extents if extent.data == True])
    fullBackupSize = sum([extent.length for extent in extents])
    logger.info("Got %s extents" % len(extents))
    logger.info("%s bytes imagesize" % fullBackupSize)
    logger.info("%s bytes of data extents to backup" % thinBackupSize)

    if args.level == "inc" and thinBackupSize == 0:
        logger.info("No dirty blocks found")
        return True

    if checkpointName == None:
        targetFile = '%s.%s.data' % (
            args.file,
            diskTarget
        )
    else:
        targetFile = '%s.%s.inc.%s.data' % (
            args.file,
            diskTarget,
            checkpointName
        )

    if args.file == '-':
        if args.type == 'stream':
            writer = sys.stdout.buffer
        else:
            logger.error('Stdout not supported with raw output')
    else:
        logger.info("Write data to target file: %s" % targetFile)
        writer = open(targetFile,'wb')
    if args.type == "raw":
        logging.info("Creating full provisioned raw backup image")
        writer.truncate(fullBackupSize)
        writer.seek(0)
    else:
        logging.info("Creating thin provisioned stream backup image")
        inc = False
        if args.level == "inc":
            inc = True
        metadata = sparsestream.SparseStream().dump_metadata(
            fullBackupSize,
            thinBackupSize,
            diskTarget,
            "none",
            inc
        )
        sparsestream.SparseStream().write_frame(writer,
            sparsestream.SparseStreamTypes().META,
            0,
            len(metadata)
        )
        writer.write(metadata)
        writer.write(sparsestream.SparseStreamTypes().TERM)

    for save in extents:
        if save.data == True:
            if args.type == "stream":
                sparsestream.SparseStream().write_frame(writer,
                    sparsestream.SparseStreamTypes().DATA,
                    save.offset,
                    save.length
                )
            if save.length >= nbdClient.maxRequestSize:
                bs = nbdClient.minRequestSize
                assert save.length % bs == 0
                offset = save.offset
                count = int(save.length/bs)
                ct = 1
                while ct <= count:
                    if args.type == "raw":
                        writer.seek(offset)
                    writer.write(connection.pread(bs, offset))
                    ct+=1
                    offset+=bs
            else:
                if args.type == "raw":
                    writer.seek(save.offset)
                writer.write(connection.pread(save.length, save.offset))
            if args.type == "stream":
                writer.write(sparsestream.SparseStreamTypes().TERM)
        else:
            if args.type == "raw":
                writer.seek(save.offset)
            elif args.type == "stream":
                sparsestream.SparseStream().write_frame(writer,
                    sparsestream.SparseStreamTypes().ZERO,
                    save.offset,
                    save.length
                )
    if args.type == "stream":
        sparsestream.SparseStream().write_frame(writer, sparsestream.SparseStreamTypes().STOP, 0, 0)
        writer.close()

if __name__ == "__main__":
    main()
