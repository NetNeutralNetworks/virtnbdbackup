#!/usr/bin/python3
"""
    Copyright (C) 2021 Michael Ablassmeier <abi@grinser.de>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
import os
import sys
import shutil
import logging
import argparse
import pprint

from libvirtnbdbackup import __version__
from libvirtnbdbackup import common
from libvirtnbdbackup import nbdhelper
from libvirtnbdbackup import libvirthelper
from libvirtnbdbackup import qemuhelper
from libvirtnbdbackup import outputhelper
from libvirtnbdbackup import exceptions as baseexception
from libvirtnbdbackup.logcount import logCount
from libvirtnbdbackup.sparsestream import streamer
from libvirtnbdbackup.sparsestream import types
from libvirtnbdbackup.sparsestream import exceptions


def dump(lib, args, stream, dataFiles):
    """Dump stream contents to json output"""
    logging.info("Dumping saveset meta information")
    for dataFile in dataFiles:
        if args.disk is not None and not os.path.basename(dataFile).startswith(
            args.disk
        ):
            continue
        logging.info(dataFile)

        sourceFile = dataFile
        if args.sequence:
            sourceFile = f"{args.input}/{dataFile}"
        meta = getHeader(lib, sourceFile, stream)

        if not meta:
            return False

        pprint.pprint(meta)

        if lib.isCompressed(meta):
            logging.info("Compressed stream found: [%s].", meta["compressionMethod"])

    return True


def restoreData(lib, args, stream, dataFile, targetFile, nbdClient, connection):
    """Restore data for disk"""
    try:
        reader = open(dataFile, "rb")
    except OSError as errmsg:
        logging.critical("Unable to open backup file for reading: [%s].", errmsg)
        return False

    sTypes = types.SparseStreamTypes()

    try:
        kind, start, length = stream.readFrame(reader)
        meta = stream.loadMetadata(reader.read(length))
    except exceptions.StreamFormatException as errmsg:
        logging.fatal(errmsg)
        raise baseexception.RestoreError from errmsg

    if lib.isCompressed(meta) is True:
        trailer = stream.readCompressionTrailer(reader)
        logging.info("Found compression trailer.")
        logging.debug("%s", trailer)
    else:
        trailer = None

    if meta["dataSize"] == 0:
        logging.info("File [%s] contains no dirty blocks, skipping.", dataFile)
        return True

    logging.info(
        "Applying data from backup file [%s] to target file [%s].", dataFile, targetFile
    )
    pprint.pprint(meta)
    assert reader.read(len(sTypes.TERM)) == sTypes.TERM

    progressBar = lib.progressBar(
        meta["dataSize"], f"restoring disk [{meta['diskName']}]", args
    )
    dataSize = 0
    dataBlockCnt = 0
    while True:
        try:
            kind, start, length = stream.readFrame(reader)
        except exceptions.StreamFormatException as err:
            logging.error("Cant read stream at pos: %s: %s", reader.tell(), err)
            raise baseexception.RestoreError from err
        if kind == sTypes.ZERO:
            logging.debug("Zero segment from %s length: %s", start, length)
        elif kind == sTypes.DATA:
            logging.debug("Processing data segment from %s length: %s", start, length)

            originalSize = length
            if trailer:
                logging.debug("Block: %s", dataBlockCnt)
                logging.debug("Original block size: %s", length)
                length = trailer[dataBlockCnt]
                logging.debug("Compressed block size: %s", length)

            if originalSize >= nbdClient.maxRequestSize:
                logging.debug("Chunked read/write, start: %s, len: %s", start, length)
                try:
                    written = lib.readChunk(
                        reader,
                        start,
                        length,
                        nbdClient.maxRequestSize,
                        connection,
                        lib.isCompressed(meta),
                    )
                except Exception as e:
                    raise baseexception.RestoreError from e
                logging.debug("Wrote: %s", written)
            else:
                try:
                    data = reader.read(length)
                    if lib.isCompressed(meta):
                        data = lib.lz4DecompressFrame(data)
                    connection.pwrite(data, start)
                    written = len(data)
                except Exception as e:
                    raise baseexception.RestoreError from e

            assert reader.read(len(sTypes.TERM)) == sTypes.TERM
            dataSize += originalSize
            progressBar.update(written)
            dataBlockCnt += 1
        elif kind == sTypes.STOP:
            progressBar.close()
            if dataSize != meta["dataSize"]:
                logging.error(
                    "Error: restored data size %s != %s",
                    dataSize,
                    meta["dataSize"],
                )
                raise baseexception.RestoreError
            break

    logging.info("End of stream, %s bytes of data processed", dataSize)
    if meta["checkpointName"] == args.until:
        logging.info("Reached checkpoint %s, stopping", args.until)
        raise baseexception.UntilCheckpointReached

    return True


def restoreSequence(lib, args, dataFiles):
    """Reconstruct image from a given set of data files"""
    stream = streamer.SparseStream(types)

    for disk in dataFiles:
        sourceFile = f"{args.input}/{disk}"

        meta = getHeader(lib, sourceFile, stream)
        if not meta:
            return False

        diskName = meta["diskName"]
        targetFile = f"{args.output}/{diskName}"

        if not os.path.exists(targetFile):
            if not createDiskFile(meta, targetFile=targetFile):
                return False

        qFh = qemuhelper.qemuHelper(diskName)

        socketFile = lib.getSocketFile(args.socketfile)
        nbdClient, connection = startNbd(qFh, diskName, targetFile, socketFile)

        result = writeData(
            lib, args, stream, sourceFile, targetFile, nbdClient, connection
        )

        nbdClient.disconnect()

    return result


def writeData(lib, args, stream, disk, targetFile, nbdClient, connection):
    """Restore the data stream to the target file"""
    diskState = False
    diskState = restoreData(lib, args, stream, disk, targetFile, nbdClient, connection)
    # no data has been processed
    if diskState is None:
        diskState = True

    return diskState


def createDiskFile(meta, targetFile, diskFormat="qcow2"):
    """Create target image file"""
    logging.info("Create virtual Disk [%s] format: [%s]", targetFile, diskFormat)
    logging.info("Virtual Size: [%s]", meta["virtualSize"])
    qFh = qemuhelper.qemuHelper(meta["diskName"])

    try:
        qFh.create(targetFile, meta["virtualSize"], diskFormat)
    except qemuhelper.exceptions.ProcessError as e:
        logging.error("Cant create restore target: %s", e)
        return False

    return True


def getHeader(lib, diskFile, stream):
    """Read header from data file"""
    try:
        return lib.dumpMetaData(diskFile, stream)
    except exceptions.StreamFormatException as errmsg:
        logging.error("Reading metadata from %s failed: %s", diskFile, errmsg)
        return False
    except OSError as errmsg:
        logging.error("Reading data file %s failed: %s", diskFile, errmsg)
        return False


def startNbd(qFh, exportName, targetFile, socketFile):
    """Start NBD service for restore"""
    logging.info("Starting NBD server on socket: [%s]", socketFile)
    err = qFh.startRestoreNbdServer(targetFile, socketFile)
    if err.err is not None:
        logging.error("Unable to start NBD server: [%s]", err)
        return False

    nbdClient = nbdhelper.nbdClient(exportName, None, socketFile)
    return nbdClient, nbdClient.waitForServer()


def readConfig(vmConfig):
    """Read saved virtual machine config'"""
    try:
        return outputhelper.openfile(vmConfig, "rb").read().decode()
    except:
        logging.error("Cant read config file: [%s]", vmConfig)
        raise


def getDisksFromConfig(args, vmConfig):
    """Parse disk information from latest config file
    contained in the backup directory
    """
    config = readConfig(vmConfig)
    return libvirthelper.client().getDomainDisks(args, config)


def checkBackingStore(args, disk):
    """If an virtual machine was running on an snapshot image,
    warn user, the virtual machine configuration has to be
    adjusted before starting the VM is possible"""
    if len(disk.backingstores) > 0 and not args.adjust_config:
        logging.warning(
            "Target image [%s] seems to be a snapshot image.", disk.filename
        )
        logging.warning("Target virtual machine configuration must be altered!")
        logging.warning("Configured backing store images must be changed.")


def checkAdditional(args, lib, vmConfig):
    """Notice user if backed up vm had loader / nvram"""
    config = readConfig(vmConfig)
    info = libvirthelper.client().getDomainInfo(config)

    for setting, val in info.items():
        if val is not None:
            f = lib.getLatest(args.input, f"*{os.path.basename(val)}*", -1)
            logging.warning(
                "Domain config includes additional boot option: [%s]: "
                "File [%s] must be copied manually.",
                setting,
                f,
            )


def setTargetFile(args, disk):
    """Based on disk information, set target file
    to write"""
    if disk.filename is not None:
        targetFile = f"{args.output}/{disk.filename}"
    else:
        targetFile = f"{args.output}/{disk.target}"

    return targetFile


def restore(lib, args, vmConfig):
    """Handle restore operation"""
    stream = streamer.SparseStream(types)
    vmDisks = getDisksFromConfig(args, vmConfig)
    if not vmDisks:
        return False, False

    for disk in vmDisks:
        if args.disk not in (None, disk.target):
            logging.info("Skipping disk %s for restore", disk.target)
            continue

        restoreDisk = lib.getLatest(args.input, f"{disk.target}*.data")
        logging.debug("Restoring disk: %s", restoreDisk)
        if len(restoreDisk) < 1:
            logging.warning("No backup file for disk [%s] found.", disk.target)
            continue

        targetFile = setTargetFile(args, disk)

        if args.raw and disk.format == "raw":
            logging.info("Copy raw image to %s", targetFile)
            try:
                shutil.copy(restoreDisk[0], targetFile)
                continue
            except shutil.Error as errmsg:
                logging.error("Unable to copy raw image: %s", errmsg)

        if "full" not in restoreDisk[0] and "copy" not in restoreDisk[0]:
            logging.error(
                "%s Unable to locate base full or copy backup.", restoreDisk[0]
            )
            return False, False

        meta = getHeader(lib, restoreDisk[0], stream)
        if not meta:
            logging.error("Reading metadata from %s failed", restoreDisk[0])
            return False, False

        qFh = qemuhelper.qemuHelper(meta["diskName"])
        if not createDiskFile(meta, targetFile, disk.format):
            return False, False

        socketFile = lib.getSocketFile(args.socketfile)
        nbdClient, connection = startNbd(qFh, meta["diskName"], targetFile, socketFile)

        result = False
        for dataFile in restoreDisk:
            try:
                result = writeData(
                    lib, args, stream, dataFile, targetFile, nbdClient, connection
                )
            except baseexception.UntilCheckpointReached:
                result = True
                break
            except baseexception.RestoreError:
                result = False
                break

        checkBackingStore(args, disk)
        if args.adjust_config is True:
            restConfig = libvirthelper.client().adjustDomainConfig(
                args, disk, readConfig(vmConfig), targetFile
            )
        else:
            restConfig = vmConfig

    return result, restConfig


def restoreConfig(args, vmConfig, adjustedConfig):
    """Restore either original or adjusted vm configuration
    to new directory"""
    targetFile = f"{args.output}/{os.path.basename(vmConfig)}"
    if args.adjust_config is True:
        with outputhelper.openfile(targetFile, "wb") as cnf:
            cnf.write(adjustedConfig)
        logging.info("Adjusted config placed in: [%s]", targetFile)
        if args.define is False:
            logging.info("Use 'virsh define %s' to define VM", targetFile)
    else:
        shutil.copy(vmConfig, args.output)
        logging.info("Copied original vm config to [%s]", targetFile)
        logging.info("Note: virtual machine config must be adjusted manually.")


def main():
    """main function"""
    parser = argparse.ArgumentParser(
        description="Restore virtual machine disks",
        epilog=(
            "Examples:\n"
            "   # Dump backup metadata:\n"
            "\t%(prog)s -i /backup/ -o dump\n"
            "   # Complete restore with all disks:\n"
            "\t%(prog)s -i /backup/ -o /target\n"
            "   # Complete restore, adjust config and redefine vm after restore:\n"
            "\t%(prog)s -cD -i /backup/ -o /target\n"
            "   # Complete restore, adjust config and redefine vm with name 'foo':\n"
            "\t%(prog)s -cD --name foo -i /backup/ -o /target\n"
            "   # Restore only disk 'vda':\n"
            "\t%(prog)s -i /backup/ -o /target -d vda\n"
            "   # Point in time restore:\n"
            "\t%(prog)s -i /backup/ -o /target --until virtnbdbackup.2\n"
            "   # Restore and process specific file sequence:\n"
            "\t%(prog)s -i /backup/ -o /target "
            "--sequence vdb.full.data,vdb.inc.virtnbdbackup.1.data"
        ),
        formatter_class=argparse.RawTextHelpFormatter,
    )
    opt = parser.add_argument_group("General options")
    opt.add_argument(
        "-a",
        "--action",
        required=False,
        type=str,
        choices=["dump", "restore"],
        default="restore",
        help="Action to perform: (default: %(default)s)",
    )
    opt.add_argument(
        "-i",
        "--input",
        required=True,
        type=str,
        help="Directory including a backup set",
    )
    opt.add_argument(
        "-o", "--output", required=True, type=str, help="Restore target directory"
    )
    opt.add_argument(
        "-u",
        "--until",
        required=False,
        type=str,
        help="Restore only until checkpoint, point in time restore.",
    )
    opt.add_argument(
        "-s",
        "--sequence",
        required=False,
        type=str,
        default=None,
        help="Restore image based on specified backup files.",
    )
    opt.add_argument(
        "-d",
        "--disk",
        required=False,
        type=str,
        default=None,
        help="Process only disk matching target dev name. (default: %(default)s)",
    )
    opt.add_argument(
        "-n",
        "--noprogress",
        required=False,
        action="store_true",
        default=False,
        help="Disable progress bar",
    )
    opt.add_argument(
        "-f",
        "--socketfile",
        default=None,
        type=str,
        help="Use specified file for NBD Server socket instead of random file",
    )
    opt.add_argument(
        "-r",
        "--raw",
        default=False,
        action="store_true",
        help="Copy raw images as is during restore. (default: %(default)s)",
    )
    opt.add_argument(
        "-c",
        "--adjust-config",
        default=False,
        action="store_true",
        help="Adjust vm configuration during restore. (default: %(default)s)",
    )
    opt.add_argument(
        "-D",
        "--define",
        default=False,
        action="store_true",
        help="Register/define VM after restore. (default: %(default)s)",
    )
    opt.add_argument(
        "-N",
        "--name",
        default=None,
        type=str,
        help="Define restored domain with specified name",
    )

    debopt = parser.add_argument_group("Debug options")
    debopt.add_argument(
        "-v",
        "--verbose",
        required=False,
        action="store_true",
        default=False,
        help="Enable debug output",
    )

    lib = common.Common()
    args = lib.argparse(parser)

    # default values for common usage of lib.getDomainDisks
    args.exclude = None
    args.include = args.disk

    stream = streamer.SparseStream(types)

    fileLog = lib.getLogFile("virtnbdrestore.log") or sys.exit(1)

    counter = logCount()
    lib.configLogger(args, fileLog, counter)
    lib.printVersion(__version__)

    if not os.path.exists(args.input):
        logging.error("Directory [%s] does not exist.", args.input)
        sys.exit(1)

    if args.sequence is not None:
        logging.info("Using manual specified sequence of files.")
        logging.info("Disabling redefine and config adjust options.")
        args.define = False
        args.adjust_config = False
        dataFiles = args.sequence.split(",")

        if "full" not in dataFiles[0]:
            logging.error("Sequence must start with full backup.")
            sys.exit(1)
    else:
        dataFiles = lib.getLatest(args.input, "*.data") or (
            logging.error("No data files found in directory: %s", args.input),
            sys.exit(1),
        )

    if args.output == "dump":
        args.action = "dump"

    if args.action == "dump":
        dump(lib, args, stream, dataFiles)

    if args.action == "restore":
        vmConfig = lib.getLatest(args.input, "vmconfig*.xml", -1) or (
            logging.error("No domain config file found"),
            sys.exit(1),
        )
        logging.info("Latest config file found: %s", vmConfig)
        logging.info("Using latest config file: [%s]", vmConfig)

        args.level = "full"
        if not lib.targetIsEmpty(args):
            logging.error("Target directory is not empty.")
            sys.exit(1)

        if not os.path.exists(args.output):
            os.makedirs(args.output)

        ret = False
        if args.sequence is not None:
            restConfig = None
            ret = restoreSequence(lib, args, dataFiles)
        else:
            ret, restConfig = restore(lib, args, vmConfig)

        if ret is True:
            checkAdditional(args, lib, vmConfig)
            if args.define is True and args.adjust_config is False:
                logging.warning(
                    "Redefine domain needs adjusted config, please "
                    "use --adjust-config option. Skipping.."
                )
            restoreConfig(args, vmConfig, restConfig)
            if args.define is True and args.adjust_config is True:
                if not libvirthelper.client().defineDomain(restConfig):
                    sys.exit(1)
        else:
            sys.exit(1)


if __name__ == "__main__":
    main()
